---
import type { CollectionEntry } from 'astro:content'

interface Props {
    posts: CollectionEntry<'posts'>[]
}

const { posts } = Astro.props

// Extraer todos los tags √∫nicos de todos los posts
const allTags = [...new Set(posts.flatMap(post => post.data.tags || []))].sort()
---

<div class="posts-filter-container mb-8 p-6 bg-gradient-to-r from-amber-50 to-orange-50 dark:from-neutral-800 dark:to-neutral-700 rounded-xl border border-amber-200 dark:border-neutral-600">
    <!-- Buscador de tags -->
    <div class="mb-6">
        <label for="tag-search" class="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
            üîç Buscar por hashtag
        </label>
        <input
            type="text"
            id="tag-search"
            placeholder="Escribe un hashtag para buscar..."
            class="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-red-500 focus:border-red-500 dark:bg-neutral-700 dark:text-white transition-all duration-300"
        />
    </div>

    <!-- Selecci√≥n de tags -->
    <div class="mb-4">
        <h3 class="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3">
            üè∑Ô∏è Filtrar por hashtags
        </h3>
        <div class="flex flex-wrap gap-2" id="tags-container">
            <button
                class="tag-filter-btn active px-3 py-2 text-sm font-medium rounded-full border-2 transition-all duration-300 bg-red-600 text-white border-red-600 hover:bg-red-700"
                data-tag="all"
            >
                Todos los posts
            </button>
            {allTags.map(tag => (
                <button
                    class="tag-filter-btn px-3 py-2 text-sm font-medium rounded-full border-2 transition-all duration-300 bg-white text-gray-700 border-gray-300 hover:bg-gray-50 dark:bg-neutral-600 dark:text-gray-200 dark:border-neutral-500 dark:hover:bg-neutral-500"
                    data-tag={tag}
                >
                    #{tag}
                </button>
            ))}
        </div>
    </div>

    <!-- Contador de resultados -->
    <div class="text-sm text-gray-600 dark:text-gray-400">
        <span id="results-count">Mostrando {posts.length} posts</span>
    </div>
</div>

<style>
.posts-filter-container {
    background-image: url('/src/images/paper-texture.webp');
    background-size: cover;
    background-position: center;
    background-blend-mode: multiply;
    box-shadow: 
        0 4px 12px rgba(0, 0, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.tag-filter-btn.active {
    background-color: var(--ww2-color-primary, #b3413e) !important;
    color: white !important;
    border-color: var(--ww2-color-primary, #b3413e) !important;
    transform: scale(1.05);
    box-shadow: 0 2px 8px rgba(179, 65, 62, 0.3);
}

.tag-filter-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

#tag-search:focus {
    box-shadow: 0 0 0 3px rgba(179, 65, 62, 0.1);
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const tagButtons = document.querySelectorAll('.tag-filter-btn');
    const searchInput = document.getElementById('tag-search') as HTMLInputElement;
    const resultsCount = document.getElementById('results-count');
    const blogCards = document.querySelectorAll('.blog-card');

    let activeTag = 'all';
    let searchTerm = '';

    // Funci√≥n para filtrar posts
    function filterPosts() {
        let visibleCount = 0;

        blogCards.forEach(card => {
            const cardElement = card as HTMLElement;
            const postTags = cardElement.dataset.tags?.split(',') || [];
            
            let showCard = true;

            // Filtrar por tag activo
            if (activeTag !== 'all') {
                showCard = postTags.includes(activeTag);
            }

            // Filtrar por b√∫squeda
            if (searchTerm && showCard) {
                showCard = postTags.some(tag => 
                    tag.toLowerCase().includes(searchTerm.toLowerCase())
                );
            }

            if (showCard) {
                cardElement.style.display = 'block';
                cardElement.style.animation = 'fadeIn 0.3s ease-in';
                visibleCount++;
            } else {
                cardElement.style.display = 'none';
            }
        });

        // Actualizar contador
        if (resultsCount) {
            resultsCount.textContent = `Mostrando ${visibleCount} posts`;
        }
    }

    // Event listeners para botones de tags
    tagButtons.forEach(button => {
        button.addEventListener('click', function() {
            // Remover clase active de todos los botones
            tagButtons.forEach(btn => btn.classList.remove('active'));
            
            // Agregar clase active al bot√≥n clickeado
            this.classList.add('active');
            
            // Actualizar tag activo
            activeTag = this.dataset.tag || 'all';
            
            // Filtrar posts
            filterPosts();
        });
    });

    // Event listener para b√∫squeda
    searchInput?.addEventListener('input', function() {
        searchTerm = this.value.trim();
        filterPosts();
        
        // Si hay b√∫squeda, desactivar filtro por tag
        if (searchTerm) {
            tagButtons.forEach(btn => btn.classList.remove('active'));
            activeTag = 'all';
        }
    });

    // Limpiar b√∫squeda cuando se selecciona un tag
    tagButtons.forEach(button => {
        button.addEventListener('click', function() {
            if (searchInput) {
                searchInput.value = '';
                searchTerm = '';
            }
        });
    });
});
</script>

<style>
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
</style>
